[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ST558 Assignment 06",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\n\nlapply will take a vector or list x and apply a function FUN over it, returning a vector the same length as x. The purrr equivalent is purrr::map().\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want to use lapply() to run the code cor(numeric_matrix, method = \"kendall\") on each element of the list. Write code to do this below!\n\n\nlapply(my_list, cor, method=\"kendall\")\n\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\nThere is greater type stability, and it allows for shorthand with anonymous functions.\n\nWhat is a side-effect function?\n\nA side-effect function will do more than just to return a value based on inputs - it could change other variables outside of its own environment (like with &lt;&lt;-), or print to the console; or some other activity.\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\nBecause of the rules of scoping. If you set, for instance, sd&lt;-sd(vec), it will look for the sd() object, not find it set up within the function, and will look one or more levels higher until it finds the function. After the variable sd is set, any reference later to sd within the function will call the variable and not the higher-level sd function."
  },
  {
    "objectID": "index.html#task-1-conceptual-questions",
    "href": "index.html#task-1-conceptual-questions",
    "title": "ST558 Assignment 06",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\n\nlapply will take a vector or list x and apply a function FUN over it, returning a vector the same length as x. The purrr equivalent is purrr::map().\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want to use lapply() to run the code cor(numeric_matrix, method = \"kendall\") on each element of the list. Write code to do this below!\n\n\nlapply(my_list, cor, method=\"kendall\")\n\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\nThere is greater type stability, and it allows for shorthand with anonymous functions.\n\nWhat is a side-effect function?\n\nA side-effect function will do more than just to return a value based on inputs - it could change other variables outside of its own environment (like with &lt;&lt;-), or print to the console; or some other activity.\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\nBecause of the rules of scoping. If you set, for instance, sd&lt;-sd(vec), it will look for the sd() object, not find it set up within the function, and will look one or more levels higher until it finds the function. After the variable sd is set, any reference later to sd within the function will call the variable and not the higher-level sd function."
  },
  {
    "objectID": "index.html#task-2-writing-r-functions",
    "href": "index.html#task-2-writing-r-functions",
    "title": "ST558 Assignment 06",
    "section": "Task 2: Writing R Functions",
    "text": "Task 2: Writing R Functions\n\nA common metric used to evaluate predictions is the Root Mean Square Error (RMSE). For a given set of responses \\(y_1, ..., y_n\\) and a set of corresponding predictions for those obserations \\(\\hat{y}_1, ..., \\hat{y}_n\\) the RMSE is \\[RMSE=\\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}(y_i-\\hat{y}_i)^2}\\] Write a basic function (call it getRMSE()) that takes in a vector of responses and a vector of predictions and outputs the RMSE.\n\n\nIf a value is missing for the vector of responses (i.e, an NA is present), allow for additional arguments to the mean() function (use elipses) that removes the NA values in the computation.\n\n\ngetRMSE &lt;- function (responses, predictions, ...) {\n  sqrt(mean((responses - predictions)^2, ...))\n}\n\n\nRun the following code to create some response values and predictions.\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x * rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n\nTest your RMSE function using this data.\n\n\ngetRMSE(responses=resp, predictions=pred)\n\n[1] 5.441253\n\n\n\nRepeat after manually replacing two of the response values with missing values (NA_real_) (just assign two values to NA_real_).\nTest your RMSE function with and without specifying the behavior to deal with missing values.\n\n\n# Pick 2 numbers 1-100 at random and change those to NA_real\nresp[sample(1:100, 2)] &lt;- NA_real_\n# Just running as-is\ngetRMSE(resp, pred)\n\n[1] NA\n\n# Running once more with instructions to ignore missing values.\ngetRMSE(resp, pred, na.rm=TRUE)\n\n[1] 5.484418\n\n\n\nAnother common metric for evaluating predictions is mean absolute deviation given by \\[MAE=\\frac{1}{n}\\sum_{i=1}^{n}|y_i-\\hat{y}_i|\\] Write a function called getMAE() that follows the specifications of the getRMSE() function.\n\n\ngetMAE &lt;- function(responses, predictions, ...) {\n  mean(abs(responses - predictions), ...)\n}\n\n\nRun the following code to create some response values and predictions.\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x * rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n\nTest your MAE function using this data.\n\n\ngetMAE(resp, pred)\n\n[1] 3.877316\n\n\n\nRepeat after replacing two of the response vaues with missing values (NA_real_).\nTest your MAE function with and without specifying the behavior to deal with missing values.\n\n\n# Pick 2 numbers 1-100 at random and change those to NA_real\nresp[sample(1:100, 2)] &lt;- NA_real_\n# Just running as-is\ngetMAE(resp, pred)\n\n[1] NA\n\n# Running once more with instructions to ignore missing values.\ngetMAE(resp, pred, na.rm=TRUE)\n\n[1] 3.910145\n\n\n\nLet’s create a wrapper function that can be used to get either or both metrics returned with a single function call. Do not rewrite your above two functions, call them inside the wrapper function (we would call the getRMSE() and getMAE() functions helper functions). When returning your values, give them appropriate names.\n\nAdditionally, the wrapper function should:\n\nCheck that two numeric (atomic) vectors have been passed (consider is.vector(), is.atomic(), and is.numeric()). If not, the function should stop and print an informative message.\nReturn both metrics by default and include names. The behavior should be able to be changed using a character string of metrics to find.\n\n\ngetMetrics &lt;- function (resp, pred, mets=c(\"RMSE\",\"MAE\"), ...) {\n  checks &lt;- c(is.vector, is.atomic, is.numeric)\n  checkResp &lt;- all(sapply(checks, function(f) f(resp)))\n  checkPred &lt;- all(sapply(checks, function(f) f(pred)))\n  if (!checkResp | !checkPred) {\n    stop(\"Both the Responses and Predictions must be Numeric, Atomic, and Vectors.\")\n  }\n  helpers &lt;- list(RMSE=getRMSE, MAE=getMAE)\n  helpers &lt;- helpers[intersect(mets, names(helpers))]\n  lapply(helpers, function(h) h(resp, pred, ...))\n}\n\n\nRun the following code to create some response values and predictions.\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x * rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n\nTest your new function using this data. Call it once asking for each metric individually and once specifying both metrics.\n\n\n# Calling just RMSE\ngetMetrics(resp, pred, \"RMSE\")\n\n$RMSE\n[1] 5.441253\n\n# Calling just MAE\ngetMetrics(resp, pred, \"MAE\")\n\n$MAE\n[1] 3.877316\n\n# Specifying both, though both would be presented by default\ngetMetrics(resp, pred, c(\"RMSE\", \"MAE\"))\n\n$RMSE\n[1] 5.441253\n\n$MAE\n[1] 3.877316\n\n\n\nRepeat with replacing two of the response values with missing values (NA_real_).\n\n\n# Select two random numbers to replace.\nresp[sample(1:100, 2)] &lt;- NA_real_\n# Specify RMSE, but do not using na.rm here.\ngetMetrics(resp, pred, \"RMSE\")\n\n$RMSE\n[1] NA\n\n# Specify MAE, but DO use na.rm.\ngetMetrics(resp, pred, \"MAE\", na.rm=TRUE)\n\n$MAE\n[1] 3.910145\n\n# Get both (leave blank) and using na.rm\ngetMetrics(resp, pred, na.rm=TRUE)\n\n$RMSE\n[1] 5.484418\n\n$MAE\n[1] 3.910145\n\n\n\nFinally, test your function by passing it incorrect data (i.e. a data frameor something else instead of vectors)"
  },
  {
    "objectID": "index.html#task-3---practice-with-purrr",
    "href": "index.html#task-3---practice-with-purrr",
    "title": "ST558 Assignment 06",
    "section": "Task 3 - Practice with purrr",
    "text": "Task 3 - Practice with purrr\n\nlm_fit1 &lt;- lm(Sepal.Length ~ Sepal.Width + Species, data=iris)\n\n\nPull out the coefficients list element using $, coef(), and the pluck() function from purrr.\n\n\nlm_fit1$coefficients\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\ncoef(lm_fit1)\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\nlibrary(purrr)\nlm_fit1 |&gt; pluck(coefficients)\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n\n\nFit some different models with the following code:\n\n\nlm_fit2 &lt;- lm(Sepal.Length ~ Sepal.Width, data=iris)\nlm_fit3 &lt;- lm(Sepal.Length ~ Petal.Width + Sepal.Width + Species, data=iris)\nlm_fit4 &lt;- lm(Sepal.Length ~ Petal.Width + Petal.Length + Sepal.Width + Species, data=iris)\nfits &lt;- list(lm_fit1, lm_fit2, lm_fit3, lm_fit4)\n\nUse the purrr:map() function to pull out the coefficients of each model fit from the fits object (using pluck!)\n\nfits |&gt; map(pluck(coefficients))\n\n[[1]]\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n[[2]]\n(Intercept) Sepal.Width \n  6.5262226  -0.2233611 \n\n[[3]]\n      (Intercept)       Petal.Width       Sepal.Width Speciesversicolor \n        2.5210733         0.3715768         0.6982260         0.9881297 \n Speciesvirginica \n        1.2375878 \n\n[[4]]\n      (Intercept)       Petal.Width      Petal.Length       Sepal.Width \n        2.1712663        -0.3151552         0.8292439         0.4958889 \nSpeciesversicolor  Speciesvirginica \n       -0.7235620        -1.0234978 \n\n\n\nThere is a function called confint() that creates confidence intervals for the coefficients in an lm() fit. We apply that function directly to the fitted object like this:\n\n\nconfint(lm_fit1)\n\n                      2.5 %   97.5 %\n(Intercept)       1.5206309 2.982156\nSepal.Width       0.5933983 1.013723\nSpeciesversicolor 1.2371791 1.680307\nSpeciesvirginica  1.7491525 2.144481\n\n\nUse map() to apply the confint() function to each model fit in the fits object.\n\nfits |&gt; map(confint)\n\n[[1]]\n                      2.5 %   97.5 %\n(Intercept)       1.5206309 2.982156\nSepal.Width       0.5933983 1.013723\nSpeciesversicolor 1.2371791 1.680307\nSpeciesvirginica  1.7491525 2.144481\n\n[[2]]\n                2.5 %     97.5 %\n(Intercept)  5.579865 7.47258038\nSepal.Width -0.529820 0.08309785\n\n[[3]]\n                        2.5 %    97.5 %\n(Intercept)        1.74261803 3.2995285\nPetal.Width       -0.02042746 0.7635811\nSepal.Width        0.46205710 0.9343950\nSpeciesversicolor  0.44520784 1.5310516\nSpeciesvirginica   0.46412393 2.0110518\n\n[[4]]\n                       2.5 %      97.5 %\n(Intercept)        1.6182321  2.72430044\nPetal.Width       -0.6140049 -0.01630542\nPetal.Length       0.6937939  0.96469395\nSepal.Width        0.3257653  0.66601260\nSpeciesversicolor -1.1982739 -0.24885002\nSpeciesvirginica  -1.6831329 -0.36386273\n\n\n\nLet’s create histograms of the residuasl in each model fit. Run the code here to set up a 2x2 plotting window.\n\nPull out the residual vectors (resid) using map(). Then use walk() function with hist to create the plots.\n\npar(mfrow = c(2,2))\nfits |&gt; \n  map(resid) |&gt;\n  walk(hist)\n\n\n\n\n\n\n\n\n\nOn the list that is created from the map() function used on the resid element, use purrr::set_names() to give the names “fit1”, “fit2”, “fit3”, and “fit4” to the list of elements.\n\nWith the names set, we want to use the walk() function; however it doesn’t add the names appropriately. Instead we want iwalk(). On the result that has names, use iwalk() with an anonymous function that calls hist() and assigns the names appropiately.\n\npar(mfrow = c(2,2))\nfits |&gt; \n  map(resid) |&gt;\n  set_names(nm=c(\"fit1\",\"fit2\",\"fit3\",\"fit4\")) |&gt;\n  iwalk(\\(x, y) hist(x, main=paste(\"Residuals of\", y)))"
  }
]