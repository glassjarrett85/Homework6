---
title: "ST558 Assignment 06"
format: html
date: today()
---

## Task 1: Conceptual Questions

1. What is the purpose of the `lapply()` function? What is the equivalent `purrr` function?

2.  Suppose we have a list called `my_list`. Each element of the list is a numeric data frame (all columns are numeric). We want use `lapply()` to run the code `cor(numeric_matrix, method = "kendall")` on each element of the list. Write code to do this below! (Iâ€™m really trying to ask you how you specify `method = "kendall"` when calling `lapply()`)

3. What are two advantages of using purrr functions instead of the `BaseR apply` family?

4. What is a side-effect function?

5. Why can you name a variable `sd` in a function and not cause any issues with the `sd` function?

## Task 2: Writing R Functions

1. A common metric used to evaluate predictions is the Root Mean Square Error (RMSE). For a given set of responses $y_1, ..., y_n$ and a set of corresponding predictions for those obserations $\hat{y}_1, ..., \hat{y}_n$ the RMSE is $$RMSE=\sqrt{\frac{1}{n}\sum_{i=1}^{n}(y_i-\hat{y}_i)^2}$$ Write a basic function (call it `getRMSE()`) that takes in a *vector* of responses and a *vector* of predictions and outputs the RMSE.

* If a value is missing for the vector of responses (i.e, an `NA` is present), allow for additional arguments to the `mean()` function (use elipses) that removes the `NA` values in the computation.

2. Run the following code to create some response values and predictions.

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x * rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

  * Test your RMSE function using this data.

  * Repeat after manuappy replacing two of the response values with missing values (`NA_real_`) (just assign two values to `NA_real_`).

    + Test your RMSE function with and without specifying the behavior to deal with missing values.
  
3. Another common metric for evaluatingpredictions is mean absolute deviation given by $$MAE=\frac{1}{n}\sum_{i=1}^{n}|y_i-\hat{y}_i|$$ Write a function called `getMAE()` that follows the specifications of the `getRMSE()` function.

4. Run the following code to create some response values and predictions.

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x * rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

  * Test your MAE function using this data.
  
  * Repeat after replacing two of the response vaues with missing values (`NA_real_`).
  
    + Test your MAE function with and without specifying the behavior to deal with missing values.
    
5. Let's create a `wrapper` function that can be used to get either or both metrics returned with a single function call. Do not rewrite your above two functions, call them inside the wrapper function (we would call the `getRMSE()` and `getMAE()` functions **helper** functions). When returning your values, give them appropriate names.

  Additionally, the wrapper function should:

  * Check that two numeric (atomic) vectors have been passed (consider `is.vector()`, `is.atomic()`, and `is.numeric()`). If not, the function should stop and print an informative message.
  
  * Return both metrics by default and include names. The behavior should be able to be changed using a character string of metrics to find.
  
6. Run the following code to create some response values and predcitions.

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x * rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

  * Test your new function using this data. CAll it once asking for each metric individually and once specifying both metrics.
  
  * Repeat with replacing two of the response values with missing values (`NA_real_`).
  
  * Finally, test your function by passing it incorrect data (i.e. a data frameor something else instead of vectors)
  
## Task 3 - Practice with `purrr`

```{r}
lm_fit1 <- lm(Sepal.Length ~ Sepal.Width + Species, data=iris)
```

1. Pull out the coefficients list element using `$`, `coef()`, and the `pluck()` function from `purrr`.

2. Fit some different models with the following code:

```{r}
lm_fit2 <- lm(Sepal.Length ~ Sepal.Width, data=iris)
lm_fit3 <- lm(Sepal.Length ~ Petal.Width + Sepal.Width + Species, data=iris)
lm_fit4 <- lm(Sepal.Length ~ Petal.Width + Petal.Length + Sepal.Width + Species, data=iris)
fits <- list(lm_fit1, lm_fit2, lm_fit3, lm_fit4)
```

  Use the `purrr:map()` function to pull out the coefficients of each model fit from the `fits` object (using `pluck`!)

3. There is a function called `confint()` that creates confidence intervals for the coefficients in an `lm()` fit. We apply that function directly to the fitted object like this:

```{r}
confint(lm_fit1)
```

  Use `map()` to apply the `confint()` function to each model fit in the `fits` object.
  
4. Let's create histograms of the residuasl in each model fit. Run the code here to set up a 2x2 plotting window.

```{r}
par(mfrow = c(2,2))
```

  Pull out the residual vectors (`resid`) using `map()`. Then use `walk()` function with `hist` to create the plots.
  
5. On the list that is created from the `map()` function used on the `resid` element, use `purrr::set_names()` to give the names "fit1", "fit2", "fit3", and "fit4" to the list of elements.

  With the names set, we want to use the `walk()` function; however it doesn't add the names appropriately. Instead we want `iwalk()`. On the result that has names, use `iwalk()` with an anonymous function that calls `hist()` and assigns the names appropiately.